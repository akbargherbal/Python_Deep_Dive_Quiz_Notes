Deep Dive 1: Python
	5. Function Parameters

Full of useful tips & tricks
------------------------------------

What is the result of the following python code:
list_01 = [1,2,3,4,5,6]
a,b = a, *b

=================

What is the result of the following python code:
list_01 = [1,2,3]
list_02 = [4,5,6]

l = [*list_01, *list_02]

=================
What is the result of the following code:
x = "python"

a, *b, c = x

=================

What is the result of the following code:
dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}

for i in dict_01:
	print(i)
=================

What is the result of the following code:
dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}

for i in dict_01.items():
	print(i)
=================
Unpacking a dictionary keys:

dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}
dict_02 = {"e": 10, "d": 12, "f": 23, "g": 4}
dict_03 = {"h": 0, "i": 1, "f": 2, "k": 40}

You can unpack a dictionaries keys into a list; or a set.

This way:

list_01 = [*dict_01, *dict_02, *dict_03]

	Notice duplicate keys.
	
set_01 = {*dict_01, *dict_02, *dict_03}
	Notice duplicate keys are gone!

=================

Merging multiple dictionaries:

dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}
dict_02 = {"e": 10, "d": 12, "f": 23, "g": 4}
dict_03 = {"h": 0, "i": 1, "f": 2, "k": 40}

dict_04 = {**dict_01, **dict_02, **dict_03}

Notice latest key-value pairs are kept only!


You can also unpack dictionary on the go; consider:

dict_05 = {"aa": 11, "bb": 12, **dict_04, "cc":13}
Notice when duplicate keys exist in unpacking; only the latest pairs of key-value are kept.
=================

What is the result of the following python code:
a, *b, (c, *d) = [1, 2, 3, "python"]

a = 1
b = [2, 3]
c = "p"
d = ["y", "t", "h", "o", "n"]

=================
What is the result of the following python code:
a = [1,3,4,6]
b = "python"

l = [*a, *b]

=================
You'd better review videos on unpacking and extended unpacking ... lots of cool tricks!
=================
The start (*) unpacking is helpful in some situations, consider this:

s1 = {1, 2, 3, 5, 7}
s2 = {12, 222, 3, 25, 87, 77}
s3 = {1, 22, 30, 251, 7, 23}
s4 = {10, 82, 30, 251, 7, 5, 9}


Using traditional set union might be cumbersome; instead use the following

s5 = {*s1, *s2, *s3, *s4}

you can unpack to a list too.
l5 = [*s1, *s2, *s3, *s4]

That's equivalent to:
s5 = s1.union(s2).union(s3).union(s4)
s5 = s1.union(s2, s3, s4, s5)
=================

What is the result of the following python code:
a, b, (c, d, *e) = [1, 2, "python"]

=================
What is the result of the following python code:
a, b, (c, *d, e) = [1, 2, "python"]
=================

args & *args

def func_01(a, b, *c):
	code

func_01(10, 20, "x", "y")

Notice that:
	a = 10
	b = 20
	c = ("x", "y")		<-------------- tuple; not a list like in normal star (*) unpacking!

=================

def func_01(a, b, *args):
	code
*args is the naming convention.


=================
ERROR: THIS WON'T WORK
xxxxxxxxxxxxxxxxxxxxxxxx
def func_02(a, b, args*, d):
	code
xxxxxxxxxxxxxxxxxxxxxxxx
It works in normal unpacking; but not in functions arguments. Use keywords instead to rectify!
=================
Q:
Is the following code valid?

	def func_03(a, b, *c):
		print(a)
		print(b)
		print(c)

	func_03(10, 30)
	
A:
	Yes; a will be 10, b will be 30, and c will be an empty tuple.
	See 5. Function Parameters - 10. args.
	
=================
Q:
What is the name of (x)?
Why is x is used in this case?

def avg(*args):
	count = len(args)
	total = sum(args)
	return count and total/count	# x

A:
	x is in this case is used for short-circuiting.
	x is used to avoid division by zero.
	It seems you skipped a very important lesson in Numeric Types chapter (Booleans & Truthiness!!)
	
=================


****************	Booleans Section	****************

Backtracking to Booleans (Numeric Types Chapter) - Very Important!!!

=================

A boolean is a subclass of an integer.
	issubclass(bool, int)
	True
	
=================
Q:
What is the output of the following code?
	True == 1
A:
	True
=================

Q:
What is the output of the following code?
	0 == False
A:
	True
	
=================
Q:
What is the output of the following code?
	int(True)
A:
	1

=================
Q:
What is the output of the following code?
	int(False)
A:
	0
	
=================

Becareful; True and 1 are NOT the same objects.
They have different memory addresses!

Becareful; False and 0 are NOT the same objects.
They have different memory addresses!

id(0) != id(False)
True

id(1) != id(True)
True

=================
Q:
	What is the output of the following code?
	True + 1
A:
	2

=================

Q:
	What is the output of the following code?
	(True + True) * 4
A:
	8
=================

Q:
	What is the output of the following code?
	True < False
A:
	False
	
=================
Q:
	What is the output of the following code?
	(1 == 2) == 0
A:
	True
	False == False == True
	

=================
Q:
	Which is correct?
		a) issubclass(int, bool)
		b) issubclass(bool, int)
A:
	b - boolean is subclass of the integer type.
=================

id(3 < 4) == id(True)
(3 < 4) is True

=================

Q:
	What is the output of the following code?
	-True
A:
	-1
	
=================
Every object in python has a True truth value, except:
	1)	None
	2)	False
	3)	0
	4)	Empty sequences (e.g. tuple, list, string)
	5)	Empty mapping types (e.g. dictionary, set, etc)
	6)	Custom classes that implement __bool__ or __len__ 
		methods that returns 0 or False.


=================
Operator Precedence:
	()
	<	>	<=	>=	==	!=	in	is
	not
	and
	or
	
	Example:
		True or True and False
		True or (True and False)
		True or False == True
		
	Example:
		a < b or a > c and not x or y
		(a < b) or (a > c) and not x or y
		(a < b) or (a > c) and (not x) or y
		((a < b) or ((a > c)) and (not x)) or y
		
=================

Short-Circuiting:
	True or Y			Always return True
	False an Y			Always return False
	
=================

Short-Circuiting is useful here to avoid Zero Division Error!
a = 10
b = 0

if b and a/b > 2:
	print("a is at least twice b")

Since b is False the IF statement won't be executed.
The same goes for b == None.

=================
Example of using short-circuiting:

import string
name = "" # the user didn't provide a valid name in this case it's an empty string.

if name and name[0] in string.digits:
	print("Name cannot start with a digit.")


=================
Short-Circuiting revisited:
	x and y
	If x is truthy, evaluates y and returns it.
	If x is falsy, returns x.
	
	x or y
	If x is truthy, returns x; otherwise evaluates y and returns it.
	
	Application of OR:
	1)	Avoiding division by zero.		# This can be done using AND in a different manner.
	2)	Assigning default values.
	
	Example:
		1 or 1/0
		# In this example the division by zero won't be executed; because of short-circuiting.
		
	Example:
		s1 = None
		s2 = ""
		s3 = "abc"
		
		s1 = s1 or "n/a"
		s2 = s2 or "n/a"
		s3 = s3 or "n/a"
		
		print(s1, s2, s3)
		
		Output:
			("n/a", "n/a", "abc")
			# In this example the if s is falsy; we return "n/a"; otherwise we return s.
			
			
	In OR we look for true value; the first the better.
	In AND we look for false value; the latter the better.
	
	
	Example:
		You want to return the first character of a string s, or an empty string if
		the string is None or empty.
		
			if s:
				return s[0]
			else:
				return ""
 
=================
****************	Booleans Section	****************
