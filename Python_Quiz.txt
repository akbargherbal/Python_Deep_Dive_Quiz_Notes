Deep Dive 1: Python
	5. Function Parameters

Full of useful tips & tricks
------------------------------------

What is the result of the following python code:
list_01 = [1,2,3,4,5,6]
a,b = a, *b

=================

What is the result of the following python code:
list_01 = [1,2,3]
list_02 = [4,5,6]

l = [*list_01, *list_02]

=================
What is the result of the following code:
x = "python"

a, *b, c = x

=================

What is the result of the following code:
dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}

for i in dict_01:
	print(i)
=================

What is the result of the following code:
dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}

for i in dict_01.items():
	print(i)
=================
Unpacking a dictionary keys:

dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}
dict_02 = {"e": 10, "d": 12, "f": 23, "g": 4}
dict_03 = {"h": 0, "i": 1, "f": 2, "k": 40}

You can unpack a dictionaries keys into a list; or a set.

This way:

list_01 = [*dict_01, *dict_02, *dict_03]

	Notice duplicate keys.
	
set_01 = {*dict_01, *dict_02, *dict_03}
	Notice duplicate keys are gone!

=================

Merging multiple dictionaries:

dict_01 = {"a": 1, "b": 2, "c": 3, "d": 4}
dict_02 = {"e": 10, "d": 12, "f": 23, "g": 4}
dict_03 = {"h": 0, "i": 1, "f": 2, "k": 40}

dict_04 = {**dict_01, **dict_02, **dict_03}

Notice latest key-value pairs are kept only!


You can also unpack dictionary on the go; consider:

dict_05 = {"aa": 11, "bb": 12, **dict_04, "cc":13}
Notice when duplicate keys exist in unpacking; only the latest pairs of key-value are kept.
=================

What is the result of the following python code:
a, *b, (c, *d) = [1, 2, 3, "python"]

a = 1
b = [2, 3]
c = "p"
d = ["y", "t", "h", "o", "n"]

=================
What is the result of the following python code:
a = [1,3,4,6]
b = "python"

l = [*a, *b]

=================
You'd better review videos on unpacking and extended unpacking ... lots of cool tricks!
=================
The start (*) unpacking is helpful in some situations, consider this:

s1 = {1, 2, 3, 5, 7}
s2 = {12, 222, 3, 25, 87, 77}
s3 = {1, 22, 30, 251, 7, 23}
s4 = {10, 82, 30, 251, 7, 5, 9}


Using traditional set union might be cumbersome; instead use the following

s5 = {*s1, *s2, *s3, *s4}

you can unpack to a list too.
l5 = [*s1, *s2, *s3, *s4]

That's equivalent to:
s5 = s1.union(s2).union(s3).union(s4)
s5 = s1.union(s2, s3, s4, s5)
=================

What is the result of the following python code:
a, b, (c, d, *e) = [1, 2, "python"]

=================
What is the result of the following python code:
a, b, (c, *d, e) = [1, 2, "python"]
=================

args & *args

def func_01(a, b, *c):
	code

func_01(10, 20, "x", "y")

Notice that:
	a = 10
	b = 20
	c = ("x", "y")		<-------------- tuple; not a list like in normal star (*) unpacking!

=================

def func_01(a, b, *args):
	code
*args is the naming convention.


=================
ERROR: THIS WON'T WORK
xxxxxxxxxxxxxxxxxxxxxxxx
def func_02(a, b, args*, d):
	code
xxxxxxxxxxxxxxxxxxxxxxxx
It works in normal unpacking; but not in functions arguments. Use keywords instead to rectify!
=================
Q:
Is the following code valid?

	def func_03(a, b, *c):
		print(a)
		print(b)
		print(c)

	func_03(10, 30)
	
A:
	Yes; a will be 10, b will be 30, and c will be an empty tuple.
	See 5. Function Parameters - 10. args.
	
=================
Q:
What is the name of (x)?
Why is x is used in this case?

def avg(*args):
	count = len(args)
	total = sum(args)
	return count and total/count	# x

A:
	x is in this case is used for short-circuiting.
	x is used to avoid division by zero.
	It seems you skipped a very important lesson in Numeric Types chapter (Booleans & Truthiness!!)
	
=================


****************	Booleans Section	****************

Backtracking to Booleans (Numeric Types Chapter) - Very Important!!!

=================

A boolean is a subclass of an integer.
	issubclass(bool, int)
	True
	
=================
Q:
What is the output of the following code?
	True == 1
A:
	True
=================

Q:
What is the output of the following code?
	0 == False
A:
	True
	
=================
Q:
What is the output of the following code?
	int(True)
A:
	1

=================
Q:
What is the output of the following code?
	int(False)
A:
	0
	
=================

Becareful; True and 1 are NOT the same objects.
They have different memory addresses!

Becareful; False and 0 are NOT the same objects.
They have different memory addresses!

id(0) != id(False)
True

id(1) != id(True)
True

=================
Q:
	What is the output of the following code?
	True + 1
A:
	2

=================

Q:
	What is the output of the following code?
	(True + True) * 4
A:
	8
=================

Q:
	What is the output of the following code?
	True < False
A:
	False
	
=================
Q:
	What is the output of the following code?
	(1 == 2) == 0
A:
	True
	False == False == True
	

=================
Q:
	Which is correct?
		a) issubclass(int, bool)
		b) issubclass(bool, int)
A:
	b - boolean is subclass of the integer type.
=================

id(3 < 4) == id(True)
(3 < 4) is True

=================

Q:
	What is the output of the following code?
	-True
A:
	-1
	
=================
Every object in python has a True truth value, except:
	1)	None
	2)	False
	3)	0
	4)	Empty sequences (e.g. tuple, list, string)
	5)	Empty mapping types (e.g. dictionary, set, etc)
	6)	Custom classes that implement __bool__ or __len__ 
		methods that returns 0 or False.


=================
Operator Precedence:
	()
	<	>	<=	>=	==	!=	in	is
	not
	and
	or
	
	Example:
		True or True and False
		True or (True and False)
		True or False == True
		
	Example:
		a < b or a > c and not x or y
		(a < b) or (a > c) and not x or y
		(a < b) or (a > c) and (not x) or y
		((a < b) or ((a > c)) and (not x)) or y
		
=================

Short-Circuiting:
	True or Y			Always return True
	False an Y			Always return False
	
=================

Short-Circuiting is useful here to avoid Zero Division Error!
a = 10
b = 0

if b and a/b > 2:
	print("a is at least twice b")

Since b is False the IF statement won't be executed.
The same goes for b == None.

=================
Example of using short-circuiting:

import string
name = "" # the user didn't provide a valid name in this case it's an empty string.

if name and name[0] in string.digits:
	print("Name cannot start with a digit.")


=================
Short-Circuiting revisited:
	x and y
	If x is truthy, evaluates y and returns it.
	If x is falsy, returns x.
	
	x or y
	If x is truthy, returns x; otherwise evaluates y and returns it.
	
	Application of OR:
	1)	Avoiding division by zero.		# This can be done using AND in a different manner.
	2)	Assigning default values.
	
	Example:
		1 or 1/0
		# In this example the division by zero won't be executed; because of short-circuiting.
		
	Example:
		s1 = None
		s2 = ""
		s3 = "abc"
		
		s1 = s1 or "n/a"
		s2 = s2 or "n/a"
		s3 = s3 or "n/a"
		
		print(s1, s2, s3)
		
		Output:
			("n/a", "n/a", "abc")
			# In this example the if s is falsy; we return "n/a"; otherwise we return s.
			
			
	In OR we look for true value; the first the better.
	In AND we look for false value; the latter the better.
	
	
	Example:
		You want to return the first character of a string s, or an empty string if
		the string is None or empty.
		
			if s:
				return s[0]
			else:
				return ""
 
=================
****************	Booleans Section	****************

=================
Q:
	Why is the following code will result in an exception?
	
	def func01(a, b, *args, d):
		print(a, b, args, d)
	
A:
	Because the function after exhausting the args (arguments) in the function signature, it will have to look for a keyword argument (d); and it will have nothing ... it was catched by the *args. 
	Thus after *args, keywords will have to be named.

=================
Q:
	The following function is wrong, how could you correct it?
	
	def func01(a, b, *args, d):
		print(a, b, args, d)

A:
	def func01(a, b, *args, d=3):
		print(a, b, args, d)
=================

Q:
	What are the differences between *args and **kwargs?

A:	
	1)	*args is used to scope up variable amount of remaining positional arguments.
	2) 	args are stored in a tuple
	3) 	*kwargs is used to scope up variable amount of remaining keyword arguments.
	4)	kwargs are stored in a dictionary.
	
=================

Q:
	Explain the following function signature:
		def func(*, d, **kwargs):
			# code
A:
	*			denotes:	we don't have any positional arguments.
	d			denotes:	d is a mandatory keyword argument.
	**kwargs	denotes:	kwargs will scope up any remaining keyword arguments.

=================

Q:
	What is the output of the following function?
		def func(*, d, **kwargs):
			print(f"d = {d}")
			print(f"kwargs = {kwargs}")
		
		func(d=1, a=2, b=3)
A:
	d = 1
	kwargs = {'a': 2, 'b': 3}
	
=================

Combining *args with *kwargs:
	1)	def func(a, b=1)
			# a is a mandatory argument; b defaults to 10 if not modified.
	2)	def func(a, b, *args)
			# a and b are a mandatory arguments; args scope up any additional arguments.
	3)	def func(a, b, *args, kw1, kw2=100)
			# a and b are a mandatory arguments; args scope up any additional arguments, kw1 is a mandatory argument, kw2 defaults to 100 if not modified.
	4)	def func(a, b, *, kw1, kw2=100)
			# a is a mandatory argument, b defaults to 10 if not modified; * (the star) indicates that we can't specify any additional arguments, kw1 is a mandatory argument, kw2 defaults to 100 if not modified.
	5)	def func(a, b, *args, kw1, kw2=100, **kwargs)
			# a and be are mandatory arguments, *args scope up any additional arguments, kw1 is a mandatory keyword argument, kw2 defaults to 100 if not modified, **kwargs scope up any additional keywords arguments.
	6)	def func(a, b=10, *, kw1, kw2=100, **kwargs)
			# a is a mandatory argument, b defaults to 10 if not modified, * (the star) indicates that we can't specify any additional arguments, kw1 is a mandatory keyword argument, kw2 defaults to 100 if not modified, **kwargs scope up any additional keywords arguments.
	7)	def func(*args)
			# args scope up any specified arguments; it can be zero arguments.
	8)	def func(**kwargs)
			# kwargs scope up any specified keywords arguments, it can be zero keyword arguments.
	9)	def (*args, **kwargs)
			# arbitrary number of arguments and keywords arguments; very common syntax.

=================

Q:
	What's wrong with the following code?
		def log(msg, *, dt=datetime.utcnow()):
			print(f'{dt}:{msg}')
A:
	dt=datetime.utcnow() in the function signature will be evaluated once; and that's it.
	That will result in it being one value; the value it was evaluated the first time.

=================
Q:
	Correct the following code so that dt reflect the current time.
		def log(msg, *, dt=datetime.utcnow()):
			print(f'{dt}:{msg}')
A:
	def log(msg, *, dt=None):
		dt = dt or datetime.utcnow()
		print(f'{dt}:{msg}')
		
		# Short-Circuiting is being used here; dt gets evaluated if it's falsy; None in this case.

=================

 Q:
	Why is it unwise to use mutable types (like list, dictionary etc) as a default function parameter, and used None instead?
	
A:
	Because the function definition runs once, and then that mutable parameter is modified every time we call the function; even for different variables.
=================

 Q:
	It is generally inadvisable to use mutable types (like list, dictionary etc) as a default function parameter, and use None instead, but that approach has some applications; show one.
	
A:
	Calculating factorial of a number.
		def factorial(n, cache={}):
			# cache is a mutable dictionary that gets created if not given by the user.
			# The dictionary cache is created once; and then gets updated as you call the function.
			
			if n < 1:
				return 1
			elif n in cache:
				return cache[n]
			else:
				print('calculating {0}!'.format(n))
				result = n * factorial(n-1)
				cache[n] = result
				return result
				
Check video titled [18. Parameter Defaults - Beware Again!!.mp4] for further info.
=================